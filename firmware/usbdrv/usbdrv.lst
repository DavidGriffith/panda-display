GAS LISTING /tmp/cccLNHGr.s 			page 1


   1               		.file	"usbdrv.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/dave/proj/boards/panda-usb/firmware/",100,0,2,.Ltext0
   8               		.stabs	"usbdrv/usbdrv.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,0,
  18               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,0,0
  19               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,0,0
  20               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,0,0
  21               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,0,0
  22               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,0,0
  23               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,0,0
  24               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,0,0
  25               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"short _Fract:t(0,15)=r(0,1);1;0;",128,0,0,0
  27               		.stabs	"_Fract:t(0,16)=r(0,1);2;0;",128,0,0,0
  28               		.stabs	"long _Fract:t(0,17)=r(0,1);4;0;",128,0,0,0
  29               		.stabs	"long long _Fract:t(0,18)=r(0,1);8;0;",128,0,0,0
  30               		.stabs	"unsigned short _Fract:t(0,19)=r(0,1);1;0;",128,0,0,0
  31               		.stabs	"unsigned _Fract:t(0,20)=r(0,1);2;0;",128,0,0,0
  32               		.stabs	"unsigned long _Fract:t(0,21)=r(0,1);4;0;",128,0,0,0
  33               		.stabs	"unsigned long long _Fract:t(0,22)=r(0,1);8;0;",128,0,0,0
  34               		.stabs	"_Sat short _Fract:t(0,23)=r(0,1);1;0;",128,0,0,0
  35               		.stabs	"_Sat _Fract:t(0,24)=r(0,1);2;0;",128,0,0,0
  36               		.stabs	"_Sat long _Fract:t(0,25)=r(0,1);4;0;",128,0,0,0
  37               		.stabs	"_Sat long long _Fract:t(0,26)=r(0,1);8;0;",128,0,0,0
  38               		.stabs	"_Sat unsigned short _Fract:t(0,27)=r(0,1);1;0;",128,0,0,0
  39               		.stabs	"_Sat unsigned _Fract:t(0,28)=r(0,1);2;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned long _Fract:t(0,29)=r(0,1);4;0;",128,0,0,0
  41               		.stabs	"_Sat unsigned long long _Fract:t(0,30)=r(0,1);8;0;",128,0,0,0
  42               		.stabs	"short _Accum:t(0,31)=r(0,1);2;0;",128,0,0,0
  43               		.stabs	"_Accum:t(0,32)=r(0,1);4;0;",128,0,0,0
  44               		.stabs	"long _Accum:t(0,33)=r(0,1);8;0;",128,0,0,0
  45               		.stabs	"long long _Accum:t(0,34)=r(0,1);8;0;",128,0,0,0
  46               		.stabs	"unsigned short _Accum:t(0,35)=r(0,1);2;0;",128,0,0,0
  47               		.stabs	"unsigned _Accum:t(0,36)=r(0,1);4;0;",128,0,0,0
  48               		.stabs	"unsigned long _Accum:t(0,37)=r(0,1);8;0;",128,0,0,0
  49               		.stabs	"unsigned long long _Accum:t(0,38)=r(0,1);8;0;",128,0,0,0
  50               		.stabs	"_Sat short _Accum:t(0,39)=r(0,1);2;0;",128,0,0,0
  51               		.stabs	"_Sat _Accum:t(0,40)=r(0,1);4;0;",128,0,0,0
  52               		.stabs	"_Sat long _Accum:t(0,41)=r(0,1);8;0;",128,0,0,0
  53               		.stabs	"_Sat long long _Accum:t(0,42)=r(0,1);8;0;",128,0,0,0
  54               		.stabs	"_Sat unsigned short _Accum:t(0,43)=r(0,1);2;0;",128,0,0,0
  55               		.stabs	"_Sat unsigned _Accum:t(0,44)=r(0,1);4;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned long _Accum:t(0,45)=r(0,1);8;0;",128,0,0,0
  57               		.stabs	"_Sat unsigned long long _Accum:t(0,46)=r(0,1);8;0;",128,0,0,0
GAS LISTING /tmp/cccLNHGr.s 			page 2


  58               		.stabs	"void:t(0,47)=(0,47)",128,0,0,0
  59               		.stabs	"usbdrv/usbdrv.h",130,0,0,0
  60               		.stabs	"usbdrv/usbportability.h",130,0,0,0
  61               		.stabs	"/usr/lib/avr/include/avr/io.h",130,0,0,0
  62               		.stabs	"/usr/lib/avr/include/avr/sfr_defs.h",130,0,0,0
  63               		.stabs	"/usr/lib/avr/include/inttypes.h",130,0,0,0
  64               		.stabs	"/usr/lib/gcc/avr/4.8.1/include/stdint.h",130,0,0,0
  65               		.stabs	"/usr/lib/avr/include/stdint.h",130,0,0,0
  66               		.stabs	"int8_t:t(7,1)=(0,10)",128,0,121,0
  67               		.stabs	"uint8_t:t(7,2)=(0,11)",128,0,122,0
  68               		.stabs	"int16_t:t(7,3)=(0,1)",128,0,123,0
  69               		.stabs	"uint16_t:t(7,4)=(0,4)",128,0,124,0
  70               		.stabs	"int32_t:t(7,5)=(0,3)",128,0,125,0
  71               		.stabs	"uint32_t:t(7,6)=(0,5)",128,0,126,0
  72               		.stabs	"int64_t:t(7,7)=(0,6)",128,0,128,0
  73               		.stabs	"uint64_t:t(7,8)=(0,7)",128,0,129,0
  74               		.stabs	"intptr_t:t(7,9)=(7,3)",128,0,142,0
  75               		.stabs	"uintptr_t:t(7,10)=(7,4)",128,0,147,0
  76               		.stabs	"int_least8_t:t(7,11)=(7,1)",128,0,159,0
  77               		.stabs	"uint_least8_t:t(7,12)=(7,2)",128,0,164,0
  78               		.stabs	"int_least16_t:t(7,13)=(7,3)",128,0,169,0
  79               		.stabs	"uint_least16_t:t(7,14)=(7,4)",128,0,174,0
  80               		.stabs	"int_least32_t:t(7,15)=(7,5)",128,0,179,0
  81               		.stabs	"uint_least32_t:t(7,16)=(7,6)",128,0,184,0
  82               		.stabs	"int_least64_t:t(7,17)=(7,7)",128,0,192,0
  83               		.stabs	"uint_least64_t:t(7,18)=(7,8)",128,0,199,0
  84               		.stabs	"int_fast8_t:t(7,19)=(7,1)",128,0,213,0
  85               		.stabs	"uint_fast8_t:t(7,20)=(7,2)",128,0,218,0
  86               		.stabs	"int_fast16_t:t(7,21)=(7,3)",128,0,223,0
  87               		.stabs	"uint_fast16_t:t(7,22)=(7,4)",128,0,228,0
  88               		.stabs	"int_fast32_t:t(7,23)=(7,5)",128,0,233,0
  89               		.stabs	"uint_fast32_t:t(7,24)=(7,6)",128,0,238,0
  90               		.stabs	"int_fast64_t:t(7,25)=(7,7)",128,0,246,0
  91               		.stabs	"uint_fast64_t:t(7,26)=(7,8)",128,0,253,0
  92               		.stabs	"intmax_t:t(7,27)=(7,7)",128,0,273,0
  93               		.stabs	"uintmax_t:t(7,28)=(7,8)",128,0,278,0
  94               		.stabn	162,0,0,0
  95               		.stabn	162,0,0,0
  96               		.stabs	"int_farptr_t:t(5,1)=(7,5)",128,0,77,0
  97               		.stabs	"uint_farptr_t:t(5,2)=(7,6)",128,0,81,0
  98               		.stabn	162,0,0,0
  99               		.stabn	162,0,0,0
 100               		.stabs	"/usr/lib/avr/include/avr/fuse.h",130,0,0,0
 101               		.stabs	"__fuse_t:t(8,1)=(8,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
 102               		.stabn	162,0,0,0
 103               		.stabn	162,0,0,0
 104               		.stabs	"/usr/lib/avr/include/avr/pgmspace.h",130,0,0,0
 105               		.stabs	"/usr/lib/gcc/avr/4.8.1/include/stddef.h",130,0,0,0
 106               		.stabs	"size_t:t(10,1)=(0,4)",128,0,212,0
 107               		.stabn	162,0,0,0
 108               		.stabn	162,0,0,0
 109               		.stabn	162,0,0,0
 110               		.stabs	"usbTxStatus:T(1,1)=s12len:(1,2)=B(0,11),0,8;buffer:(1,3)=ar(1,4)=r(1,4);0;0177777;;0;10;(0
 111               		.stabs	"usbTxStatus_t:t(1,5)=(1,1)",128,0,660,0
 112               		.stabs	"usbWord:T(1,6)=u2word:(0,4),0,16;bytes:(1,7)=ar(1,4);0;1;(0,11),0,16;;",128,0,0,0
 113               		.stabs	"usbWord_t:t(1,8)=(1,6)",128,0,672,0
 114               		.stabs	"usbRequest:T(1,9)=s8bmRequestType:(0,11),0,8;bRequest:(0,11),8,8;wValue:(1,8),16,16;wIndex
GAS LISTING /tmp/cccLNHGr.s 			page 3


 115               		.stabs	"usbRequest_t:t(1,10)=(1,9)",128,0,680,0
 116               		.stabn	162,0,0,0
 117               		.stabs	"usbSetInterrupt:F(0,47)",36,0,243,usbSetInterrupt
 118               		.stabs	"len:P(0,11)",64,0,243,28
 119               	.global	usbSetInterrupt
 120               		.type	usbSetInterrupt, @function
 121               	usbSetInterrupt:
 122               		.stabd	46,0,0
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8:usbdrv/usbdrv.c ****  */
   9:usbdrv/usbdrv.c **** 
  10:usbdrv/usbdrv.c **** #include "usbdrv.h"
  11:usbdrv/usbdrv.c **** #include "oddebug.h"
  12:usbdrv/usbdrv.c **** 
  13:usbdrv/usbdrv.c **** /*
  14:usbdrv/usbdrv.c **** General Description:
  15:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  16:usbdrv/usbdrv.c **** documentation of the entire driver.
  17:usbdrv/usbdrv.c **** */
  18:usbdrv/usbdrv.c **** 
  19:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  20:usbdrv/usbdrv.c **** 
  21:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  22:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  23:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  24:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  25:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  26:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  27:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  28:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  29:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  30:usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  31:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  32:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  33:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  34:usbdrv/usbdrv.c **** #endif
  35:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  36:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  37:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  38:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  39:usbdrv/usbdrv.c **** #   endif
  40:usbdrv/usbdrv.c **** #endif
  41:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  42:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  43:usbdrv/usbdrv.c **** #endif
  44:usbdrv/usbdrv.c **** 
  45:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  46:usbdrv/usbdrv.c **** usbMsgPtr_t         usbMsgPtr;      /* data to transmit next -- ROM or RAM address */
  47:usbdrv/usbdrv.c **** static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  48:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  49:usbdrv/usbdrv.c **** 
GAS LISTING /tmp/cccLNHGr.s 			page 4


  50:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  51:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  52:usbdrv/usbdrv.c **** 
  53:usbdrv/usbdrv.c **** /*
  54:usbdrv/usbdrv.c **** optimizing hints:
  55:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  56:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  57:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  58:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  59:usbdrv/usbdrv.c **** */
  60:usbdrv/usbdrv.c **** 
  61:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  62:usbdrv/usbdrv.c **** 
  63:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  64:usbdrv/usbdrv.c **** 
  65:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  66:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  67:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  68:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorString0[] = { /* language descriptor */
  69:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  70:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  71:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  72:usbdrv/usbdrv.c **** };
  73:usbdrv/usbdrv.c **** #endif
  74:usbdrv/usbdrv.c **** 
  75:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  76:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  77:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  78:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringVendor[] = {
  79:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
  80:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  81:usbdrv/usbdrv.c **** };
  82:usbdrv/usbdrv.c **** #endif
  83:usbdrv/usbdrv.c **** 
  84:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  85:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  86:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  87:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringDevice[] = {
  88:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  89:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  90:usbdrv/usbdrv.c **** };
  91:usbdrv/usbdrv.c **** #endif
  92:usbdrv/usbdrv.c **** 
  93:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
  94:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
  95:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
  96:usbdrv/usbdrv.c **** PROGMEM const int usbDescriptorStringSerialNumber[] = {
  97:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
  98:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
  99:usbdrv/usbdrv.c **** };
 100:usbdrv/usbdrv.c **** #endif
 101:usbdrv/usbdrv.c **** 
 102:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 103:usbdrv/usbdrv.c **** 
 104:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 105:usbdrv/usbdrv.c **** 
 106:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
GAS LISTING /tmp/cccLNHGr.s 			page 5


 107:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 108:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 109:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorDevice[] = {    /* USB device descriptor */
 110:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 111:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 112:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 113:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 114:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 115:usbdrv/usbdrv.c ****     0,                      /* protocol */
 116:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 117:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 118:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 119:usbdrv/usbdrv.c ****      */
 120:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 121:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 122:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 123:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 124:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 125:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 126:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 127:usbdrv/usbdrv.c **** };
 128:usbdrv/usbdrv.c **** #endif
 129:usbdrv/usbdrv.c **** 
 130:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 131:usbdrv/usbdrv.c **** 
 132:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 133:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 134:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 135:usbdrv/usbdrv.c **** #endif
 136:usbdrv/usbdrv.c **** 
 137:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 138:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 139:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 140:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 141:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 142:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 143:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 144:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 145:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 146:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 147:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 148:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 149:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 150:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 151:usbdrv/usbdrv.c **** #else
 152:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 153:usbdrv/usbdrv.c **** #endif
 154:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 155:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 156:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 157:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 158:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 159:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 160:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 161:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 162:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 163:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
GAS LISTING /tmp/cccLNHGr.s 			page 6


 164:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 165:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 166:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 167:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 168:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 169:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 170:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 171:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 172:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 173:usbdrv/usbdrv.c **** #endif
 174:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 175:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 176:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 177:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 178:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 179:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 180:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 181:usbdrv/usbdrv.c **** #endif
 182:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 183:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 184:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 185:usbdrv/usbdrv.c ****     (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
 186:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 187:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 188:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 189:usbdrv/usbdrv.c **** #endif
 190:usbdrv/usbdrv.c **** };
 191:usbdrv/usbdrv.c **** #endif
 192:usbdrv/usbdrv.c **** 
 193:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 194:usbdrv/usbdrv.c **** 
 195:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 196:usbdrv/usbdrv.c **** {
 197:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 198:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 199:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 201:usbdrv/usbdrv.c **** #   endif
 202:usbdrv/usbdrv.c **** #endif
 203:usbdrv/usbdrv.c **** }
 204:usbdrv/usbdrv.c **** 
 205:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 206:usbdrv/usbdrv.c **** {
 207:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 208:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 209:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 210:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 211:usbdrv/usbdrv.c **** #endif
 212:usbdrv/usbdrv.c **** #endif
 213:usbdrv/usbdrv.c **** }
 214:usbdrv/usbdrv.c **** 
 215:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 216:usbdrv/usbdrv.c **** 
 217:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 218:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 219:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 220:usbdrv/usbdrv.c **** {
GAS LISTING /tmp/cccLNHGr.s 			page 7


 221:usbdrv/usbdrv.c **** uchar   *p;
 222:usbdrv/usbdrv.c **** char    i;
 223:usbdrv/usbdrv.c **** 
 224:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 225:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 226:usbdrv/usbdrv.c ****         return;
 227:usbdrv/usbdrv.c **** #endif
 228:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 229:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 230:usbdrv/usbdrv.c ****     }else{
 231:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 232:usbdrv/usbdrv.c ****     }
 233:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 234:usbdrv/usbdrv.c ****     i = len;
 235:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 236:usbdrv/usbdrv.c ****         *p++ = *data++;
 237:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 238:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 239:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 240:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 241:usbdrv/usbdrv.c **** }
 242:usbdrv/usbdrv.c **** 
 243:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 244:usbdrv/usbdrv.c **** {
 123               		.stabn	68,0,244,.LM0-.LFBB1
 124               	.LM0:
 125               	.LFBB1:
 126 0000 CF93      		push r28
 127               	/* prologue: function */
 128               	/* frame size = 0 */
 129               	/* stack size = 1 */
 130               	.L__stack_usage = 1
 131 0002 C62F      		mov r28,r22
 132               	.LBB24:
 133               	.LBB25:
 228:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 134               		.stabn	68,0,228,.LM1-.LFBB1
 135               	.LM1:
 136 0004 2091 0000 		lds r18,usbTxStatus1
 137 0008 24FF      		sbrs r18,4
 138 000a 00C0      		rjmp .L2
 229:usbdrv/usbdrv.c ****     }else{
 139               		.stabn	68,0,229,.LM2-.LFBB1
 140               	.LM2:
 141 000c 2091 0000 		lds r18,usbTxStatus1+1
 142 0010 38E8      		ldi r19,lo8(-120)
 143 0012 2327      		eor r18,r19
 144 0014 2093 0000 		sts usbTxStatus1+1,r18
 145 0018 00C0      		rjmp .L3
 146               	.L2:
 231:usbdrv/usbdrv.c ****     }
 147               		.stabn	68,0,231,.LM3-.LFBB1
 148               	.LM3:
 149 001a 2AE5      		ldi r18,lo8(90)
 150 001c 2093 0000 		sts usbTxStatus1,r18
 151               	.L3:
 152 0020 DC01      		movw r26,r24
GAS LISTING /tmp/cccLNHGr.s 			page 8


 153               	.LBE25:
 154               	.LBE24:
 155               		.stabn	68,0,244,.LM4-.LFBB1
 156               	.LM4:
 157 0022 E0E0      		ldi r30,lo8(usbTxStatus1+2)
 158 0024 F0E0      		ldi r31,hi8(usbTxStatus1+2)
 159 0026 8C2F      		mov r24,r28
 160 0028 8E0F      		add r24,r30
 161               	.L5:
 162               	.LBB27:
 163               	.LBB26:
 236:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 164               		.stabn	68,0,236,.LM5-.LFBB1
 165               	.LM5:
 166 002a 9D91      		ld r25,X+
 167 002c 9193      		st Z+,r25
 237:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 168               		.stabn	68,0,237,.LM6-.LFBB1
 169               	.LM6:
 170 002e 8E13      		cpse r24,r30
 171 0030 00C0      		rjmp .L5
 238:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 172               		.stabn	68,0,238,.LM7-.LFBB1
 173               	.LM7:
 174 0032 6C2F      		mov r22,r28
 175 0034 80E0      		ldi r24,lo8(usbTxStatus1+2)
 176 0036 90E0      		ldi r25,hi8(usbTxStatus1+2)
 177 0038 0E94 0000 		call usbCrc16Append
 239:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 178               		.stabn	68,0,239,.LM8-.LFBB1
 179               	.LM8:
 180 003c CC5F      		subi r28,lo8(-(4))
 181 003e C093 0000 		sts usbTxStatus1,r28
 182               	/* epilogue start */
 183               	.LBE26:
 184               	.LBE27:
 245:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 246:usbdrv/usbdrv.c **** }
 185               		.stabn	68,0,246,.LM9-.LFBB1
 186               	.LM9:
 187 0042 CF91      		pop r28
 188 0044 0895      		ret
 189               		.size	usbSetInterrupt, .-usbSetInterrupt
 190               	.Lscope1:
 191               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 192               		.stabd	78,0,0
 193               		.stabs	"usbPoll:F(0,47)",36,0,568,usbPoll
 194               	.global	usbPoll
 195               		.type	usbPoll, @function
 196               	usbPoll:
 197               		.stabd	46,0,0
 247:usbdrv/usbdrv.c **** #endif
 248:usbdrv/usbdrv.c **** 
 249:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 250:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 251:usbdrv/usbdrv.c **** {
 252:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
GAS LISTING /tmp/cccLNHGr.s 			page 9


 253:usbdrv/usbdrv.c **** }
 254:usbdrv/usbdrv.c **** #endif
 255:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 256:usbdrv/usbdrv.c **** 
 257:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 258:usbdrv/usbdrv.c **** 
 259:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 260:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 261:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 262:usbdrv/usbdrv.c ****  * cases.
 263:usbdrv/usbdrv.c ****  */
 264:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 265:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 266:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 267:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 268:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 269:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 270:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 271:usbdrv/usbdrv.c **** #else
 272:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 273:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 274:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 275:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
 276:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 277:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 278:usbdrv/usbdrv.c **** #endif
 279:usbdrv/usbdrv.c **** 
 280:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 281:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 282:usbdrv/usbdrv.c **** #endif
 283:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 284:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 285:usbdrv/usbdrv.c **** #endif
 286:usbdrv/usbdrv.c **** 
 287:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 288:usbdrv/usbdrv.c **** 
 289:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 290:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 291:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 292:usbdrv/usbdrv.c ****  * optimizing!
 293:usbdrv/usbdrv.c ****  */
 294:usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 295:usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 296:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
 297:usbdrv/usbdrv.c ****             flags = 0;                              \
 298:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 299:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);        \
 300:usbdrv/usbdrv.c ****         }else{                                      \
 301:usbdrv/usbdrv.c ****             len = USB_PROP_LENGTH(cfgProp);         \
 302:usbdrv/usbdrv.c ****             usbMsgPtr = (usbMsgPtr_t)(staticName);  \
 303:usbdrv/usbdrv.c ****         }                                           \
 304:usbdrv/usbdrv.c ****     }
 305:usbdrv/usbdrv.c **** 
 306:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 307:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 308:usbdrv/usbdrv.c ****  */
 309:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
GAS LISTING /tmp/cccLNHGr.s 			page 10


 310:usbdrv/usbdrv.c **** {
 311:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 312:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 313:usbdrv/usbdrv.c **** 
 314:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 315:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 316:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 320:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 321:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 322:usbdrv/usbdrv.c ****             flags = 0;
 323:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 324:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 325:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 326:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 327:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 331:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 334:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 335:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 336:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 337:usbdrv/usbdrv.c ****             }
 338:usbdrv/usbdrv.c ****         SWITCH_END
 339:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 340:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 341:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 342:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 345:usbdrv/usbdrv.c **** #endif
 346:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 347:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 348:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 349:usbdrv/usbdrv.c ****         }
 350:usbdrv/usbdrv.c ****     SWITCH_END
 351:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 352:usbdrv/usbdrv.c ****     return len;
 353:usbdrv/usbdrv.c **** }
 354:usbdrv/usbdrv.c **** 
 355:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 356:usbdrv/usbdrv.c **** 
 357:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 358:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 359:usbdrv/usbdrv.c ****  */
 360:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 361:usbdrv/usbdrv.c **** {
 362:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 363:usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 365:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 366:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
GAS LISTING /tmp/cccLNHGr.s 			page 11


 367:usbdrv/usbdrv.c **** #endif
 368:usbdrv/usbdrv.c **** 
 369:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 370:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 371:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 372:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 373:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 374:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 375:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 376:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 377:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 378:usbdrv/usbdrv.c **** #endif
 379:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 380:usbdrv/usbdrv.c ****         len = 2;
 381:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 382:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 383:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 384:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 385:usbdrv/usbdrv.c ****             usbResetDataToggling();
 386:usbdrv/usbdrv.c ****         }
 387:usbdrv/usbdrv.c **** #endif
 388:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 389:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 390:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 391:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 392:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 393:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 394:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 395:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 396:usbdrv/usbdrv.c ****         len = 1;
 397:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 398:usbdrv/usbdrv.c ****         usbConfiguration = value;
 399:usbdrv/usbdrv.c ****         usbResetStall();
 400:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 401:usbdrv/usbdrv.c ****         len = 1;
 402:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 403:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 404:usbdrv/usbdrv.c ****         usbResetDataToggling();
 405:usbdrv/usbdrv.c ****         usbResetStall();
 406:usbdrv/usbdrv.c **** #endif
 407:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 408:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 409:usbdrv/usbdrv.c ****     SWITCH_END
 410:usbdrv/usbdrv.c ****     usbMsgPtr = (usbMsgPtr_t)dataPtr;
 411:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 412:usbdrv/usbdrv.c ****     return len;
 413:usbdrv/usbdrv.c **** }
 414:usbdrv/usbdrv.c **** 
 415:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 416:usbdrv/usbdrv.c **** 
 417:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 418:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 419:usbdrv/usbdrv.c ****  * them accordingly.
 420:usbdrv/usbdrv.c ****  */
 421:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 422:usbdrv/usbdrv.c **** {
 423:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
GAS LISTING /tmp/cccLNHGr.s 			page 12


 424:usbdrv/usbdrv.c **** 
 425:usbdrv/usbdrv.c **** /* usbRxToken can be:
 426:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 427:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 428:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 429:usbdrv/usbdrv.c ****  */
 430:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 431:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 432:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 433:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 434:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 435:usbdrv/usbdrv.c ****         return;
 436:usbdrv/usbdrv.c ****     }
 437:usbdrv/usbdrv.c **** #endif
 438:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 439:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 440:usbdrv/usbdrv.c ****             return;
 441:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 442:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 443:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 444:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 445:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 446:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 447:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 448:usbdrv/usbdrv.c ****         }else{
 449:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 450:usbdrv/usbdrv.c ****         }
 451:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 452:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 453:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 454:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 455:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 456:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 457:usbdrv/usbdrv.c ****                 }else{
 458:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 459:usbdrv/usbdrv.c ****                 }
 460:usbdrv/usbdrv.c ****             }
 461:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 462:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 463:usbdrv/usbdrv.c **** #endif
 464:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 465:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 466:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 467:usbdrv/usbdrv.c ****         }else{
 468:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 469:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 470:usbdrv/usbdrv.c ****         }
 471:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 472:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 473:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 474:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 475:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 476:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 477:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 478:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 479:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 480:usbdrv/usbdrv.c ****             }
GAS LISTING /tmp/cccLNHGr.s 			page 13


 481:usbdrv/usbdrv.c ****         }
 482:usbdrv/usbdrv.c **** #endif
 483:usbdrv/usbdrv.c ****     }
 484:usbdrv/usbdrv.c **** }
 485:usbdrv/usbdrv.c **** 
 486:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 487:usbdrv/usbdrv.c **** 
 488:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 489:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 490:usbdrv/usbdrv.c ****  */
 491:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 492:usbdrv/usbdrv.c **** {
 493:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 494:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 495:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 496:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 497:usbdrv/usbdrv.c ****         }else
 498:usbdrv/usbdrv.c **** #endif
 499:usbdrv/usbdrv.c ****         {
 500:usbdrv/usbdrv.c ****             uchar i = len;
 501:usbdrv/usbdrv.c ****             usbMsgPtr_t r = usbMsgPtr;
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 503:usbdrv/usbdrv.c ****                 do{
 504:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 505:usbdrv/usbdrv.c ****                     *data++ = c;
 506:usbdrv/usbdrv.c ****                     r++;
 507:usbdrv/usbdrv.c ****                 }while(--i);
 508:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 509:usbdrv/usbdrv.c ****                 do{
 510:usbdrv/usbdrv.c ****                     *data++ = *((uchar *)r);
 511:usbdrv/usbdrv.c ****                     r++;
 512:usbdrv/usbdrv.c ****                 }while(--i);
 513:usbdrv/usbdrv.c ****             }
 514:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 515:usbdrv/usbdrv.c ****         }
 516:usbdrv/usbdrv.c ****     }
 517:usbdrv/usbdrv.c ****     return len;
 518:usbdrv/usbdrv.c **** }
 519:usbdrv/usbdrv.c **** 
 520:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 521:usbdrv/usbdrv.c **** 
 522:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 523:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 524:usbdrv/usbdrv.c ****  */
 525:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 526:usbdrv/usbdrv.c **** {
 527:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 528:usbdrv/usbdrv.c **** uchar       len;
 529:usbdrv/usbdrv.c **** 
 530:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 531:usbdrv/usbdrv.c ****     if(wantLen > 8)
 532:usbdrv/usbdrv.c ****         wantLen = 8;
 533:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 534:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 535:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 536:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 537:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
GAS LISTING /tmp/cccLNHGr.s 			page 14


 538:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 539:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 540:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 541:usbdrv/usbdrv.c ****     }else{
 542:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 543:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 544:usbdrv/usbdrv.c ****     }
 545:usbdrv/usbdrv.c ****     usbTxLen = len;
 546:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 547:usbdrv/usbdrv.c **** }
 548:usbdrv/usbdrv.c **** 
 549:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 550:usbdrv/usbdrv.c **** 
 551:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 552:usbdrv/usbdrv.c **** {
 553:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 554:usbdrv/usbdrv.c **** static uchar    wasReset;
 555:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 556:usbdrv/usbdrv.c **** 
 557:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 558:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 559:usbdrv/usbdrv.c ****         wasReset = isReset;
 560:usbdrv/usbdrv.c ****     }
 561:usbdrv/usbdrv.c **** #else
 562:usbdrv/usbdrv.c ****     notResetState = notResetState;  // avoid compiler warning
 563:usbdrv/usbdrv.c **** #endif
 564:usbdrv/usbdrv.c **** }
 565:usbdrv/usbdrv.c **** 
 566:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 567:usbdrv/usbdrv.c **** 
 568:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 569:usbdrv/usbdrv.c **** {
 198               		.stabn	68,0,569,.LM10-.LFBB2
 199               	.LM10:
 200               	.LFBB2:
 201 0046 CF93      		push r28
 202 0048 DF93      		push r29
 203               	/* prologue: function */
 204               	/* frame size = 0 */
 205               	/* stack size = 2 */
 206               	.L__stack_usage = 2
 570:usbdrv/usbdrv.c **** schar   len;
 571:usbdrv/usbdrv.c **** uchar   i;
 572:usbdrv/usbdrv.c **** 
 573:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 207               		.stabn	68,0,573,.LM11-.LFBB2
 208               	.LM11:
 209 004a 6091 0000 		lds r22,usbRxLen
 210 004e 6350      		subi r22,lo8(-(-3))
 574:usbdrv/usbdrv.c ****     if(len >= 0){
 211               		.stabn	68,0,574,.LM12-.LFBB2
 212               	.LM12:
 213 0050 67FD      		sbrc r22,7
 214 0052 00C0      		rjmp .L8
 575:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 576:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 577:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
GAS LISTING /tmp/cccLNHGr.s 			page 15


 578:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 579:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 580:usbdrv/usbdrv.c ****  */
 581:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 215               		.stabn	68,0,581,.LM13-.LFBB2
 216               	.LM13:
 217 0054 8091 0000 		lds r24,usbInputBufOffset
 218 0058 CCE0      		ldi r28,lo8(12)
 219 005a D0E0      		ldi r29,0
 220 005c C81B      		sub r28,r24
 221 005e D109      		sbc r29,__zero_reg__
 222 0060 C050      		subi r28,lo8(-(usbRxBuf))
 223 0062 D040      		sbci r29,hi8(-(usbRxBuf))
 224               	.LBB50:
 225               	.LBB51:
 438:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 226               		.stabn	68,0,438,.LM14-.LFBB2
 227               	.LM14:
 228 0064 8091 0000 		lds r24,usbRxToken
 229 0068 8D32      		cpi r24,lo8(45)
 230 006a 01F0      		breq .+2
 231 006c 00C0      		rjmp .L9
 232               	.LBB52:
 439:usbdrv/usbdrv.c ****             return;
 233               		.stabn	68,0,439,.LM15-.LFBB2
 234               	.LM15:
 235 006e 6830      		cpi r22,lo8(8)
 236 0070 01F0      		breq .+2
 237 0072 00C0      		rjmp .L11
 442:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 238               		.stabn	68,0,442,.LM16-.LFBB2
 239               	.LM16:
 240 0074 83EC      		ldi r24,lo8(-61)
 241 0076 8093 0000 		sts usbTxBuf,r24
 443:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 242               		.stabn	68,0,443,.LM17-.LFBB2
 243               	.LM17:
 244 007a 8AE5      		ldi r24,lo8(90)
 245 007c 8093 0000 		sts usbTxLen,r24
 444:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 246               		.stabn	68,0,444,.LM18-.LFBB2
 247               	.LM18:
 248 0080 1092 0000 		sts usbMsgFlags,__zero_reg__
 445:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 249               		.stabn	68,0,445,.LM19-.LFBB2
 250               	.LM19:
 251 0084 8881      		ld r24,Y
 252 0086 8076      		andi r24,lo8(96)
 446:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 253               		.stabn	68,0,446,.LM20-.LFBB2
 254               	.LM20:
 255 0088 01F0      		breq .L12
 447:usbdrv/usbdrv.c ****         }else{
 256               		.stabn	68,0,447,.LM21-.LFBB2
 257               	.LM21:
 258 008a CE01      		movw r24,r28
 259 008c 0E94 0000 		call usbFunctionSetup
GAS LISTING /tmp/cccLNHGr.s 			page 16


 452:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 260               		.stabn	68,0,452,.LM22-.LFBB2
 261               	.LM22:
 262 0090 8F3F      		cpi r24,lo8(-1)
 263 0092 01F4      		brne .+2
 264 0094 00C0      		rjmp .L13
 265 0096 00C0      		rjmp .L14
 266               	.L12:
 267               	.LBB53:
 268               	.LBB54:
 364:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 269               		.stabn	68,0,364,.LM23-.LFBB2
 270               	.LM23:
 271 0098 9A81      		ldd r25,Y+2
 369:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 272               		.stabn	68,0,369,.LM24-.LFBB2
 273               	.LM24:
 274 009a 1092 0000 		sts usbTxBuf+9,__zero_reg__
 275               	.LBB55:
 370:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 276               		.stabn	68,0,370,.LM25-.LFBB2
 277               	.LM25:
 278 009e 8981      		ldd r24,Y+1
 371:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 279               		.stabn	68,0,371,.LM26-.LFBB2
 280               	.LM26:
 281 00a0 8111      		cpse r24,__zero_reg__
 282 00a2 00C0      		rjmp .L15
 283               	.LBB56:
 379:usbdrv/usbdrv.c ****         len = 2;
 284               		.stabn	68,0,379,.LM27-.LFBB2
 285               	.LM27:
 286 00a4 1092 0000 		sts usbTxBuf+10,__zero_reg__
 287               	.LBE56:
 288               	.LBE55:
 363:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 289               		.stabn	68,0,363,.LM28-.LFBB2
 290               	.LM28:
 291 00a8 20E0      		ldi r18,lo8(usbTxBuf+9)
 292 00aa 30E0      		ldi r19,hi8(usbTxBuf+9)
 293               	.LBB64:
 294               	.LBB57:
 380:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 295               		.stabn	68,0,380,.LM29-.LFBB2
 296               	.LM29:
 297 00ac 82E0      		ldi r24,lo8(2)
 298 00ae 00C0      		rjmp .L16
 299               	.L15:
 300               	.LBE57:
 388:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 301               		.stabn	68,0,388,.LM30-.LFBB2
 302               	.LM30:
 303 00b0 8530      		cpi r24,lo8(5)
 304 00b2 01F4      		brne .L17
 389:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 305               		.stabn	68,0,389,.LM31-.LFBB2
 306               	.LM31:
GAS LISTING /tmp/cccLNHGr.s 			page 17


 307 00b4 9093 0000 		sts usbNewDeviceAddr,r25
 308 00b8 00C0      		rjmp .L52
 309               	.L17:
 391:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 310               		.stabn	68,0,391,.LM32-.LFBB2
 311               	.LM32:
 312 00ba 8630      		cpi r24,lo8(6)
 313 00bc 01F0      		breq .+2
 314 00be 00C0      		rjmp .L18
 315               	.LBE64:
 316               	.LBE54:
 317               	.LBE53:
 318               	.LBE52:
 319               	.LBE51:
 320               	.LBE50:
 360:usbdrv/usbdrv.c **** {
 321               		.stabn	68,0,360,.LM33-.LFBB2
 322               	.LM33:
 323 00c0 8B81      		ldd r24,Y+3
 324               	.LBB72:
 325               	.LBB71:
 326               	.LBB69:
 327               	.LBB68:
 328               	.LBB67:
 329               	.LBB65:
 330               	.LBB58:
 331               	.LBB59:
 332               	.LBB60:
 315:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 333               		.stabn	68,0,315,.LM34-.LFBB2
 334               	.LM34:
 335 00c2 8130      		cpi r24,lo8(1)
 336 00c4 01F4      		brne .L19
 316:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 337               		.stabn	68,0,316,.LM35-.LFBB2
 338               	.LM35:
 339 00c6 80E0      		ldi r24,lo8(usbDescriptorDevice)
 340 00c8 90E0      		ldi r25,hi8(usbDescriptorDevice)
 341 00ca 00C0      		rjmp .L69
 342               	.L19:
 317:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 343               		.stabn	68,0,317,.LM36-.LFBB2
 344               	.LM36:
 345 00cc 8230      		cpi r24,lo8(2)
 346 00ce 01F4      		brne .L21
 318:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 347               		.stabn	68,0,318,.LM37-.LFBB2
 348               	.LM37:
 349 00d0 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 350 00d2 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 351 00d4 9093 0000 		sts usbMsgPtr+1,r25
 352 00d8 8093 0000 		sts usbMsgPtr,r24
 353 00dc 82E2      		ldi r24,lo8(34)
 354 00de 00C0      		rjmp .L20
 355               	.L21:
 319:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 356               		.stabn	68,0,319,.LM38-.LFBB2
GAS LISTING /tmp/cccLNHGr.s 			page 18


 357               	.LM38:
 358 00e0 8330      		cpi r24,lo8(3)
 359 00e2 01F4      		brne .L22
 360               	.LBB61:
 326:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 361               		.stabn	68,0,326,.LM39-.LFBB2
 362               	.LM39:
 363 00e4 9111      		cpse r25,__zero_reg__
 364 00e6 00C0      		rjmp .L23
 327:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 365               		.stabn	68,0,327,.LM40-.LFBB2
 366               	.LM40:
 367 00e8 80E0      		ldi r24,lo8(usbDescriptorString0)
 368 00ea 90E0      		ldi r25,hi8(usbDescriptorString0)
 369 00ec 9093 0000 		sts usbMsgPtr+1,r25
 370 00f0 8093 0000 		sts usbMsgPtr,r24
 371 00f4 84E0      		ldi r24,lo8(4)
 372 00f6 00C0      		rjmp .L20
 373               	.L23:
 328:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 374               		.stabn	68,0,328,.LM41-.LFBB2
 375               	.LM41:
 376 00f8 9130      		cpi r25,lo8(1)
 377 00fa 01F4      		brne .L24
 329:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 378               		.stabn	68,0,329,.LM42-.LFBB2
 379               	.LM42:
 380 00fc 80E0      		ldi r24,lo8(usbDescriptorStringVendor)
 381 00fe 90E0      		ldi r25,hi8(usbDescriptorStringVendor)
 382               	.L69:
 383 0100 9093 0000 		sts usbMsgPtr+1,r25
 384 0104 8093 0000 		sts usbMsgPtr,r24
 385 0108 82E1      		ldi r24,lo8(18)
 386 010a 00C0      		rjmp .L20
 387               	.L24:
 330:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 388               		.stabn	68,0,330,.LM43-.LFBB2
 389               	.LM43:
 390 010c 9230      		cpi r25,lo8(2)
 391 010e 01F4      		brne .L49
 331:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 392               		.stabn	68,0,331,.LM44-.LFBB2
 393               	.LM44:
 394 0110 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 395 0112 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 396 0114 9093 0000 		sts usbMsgPtr+1,r25
 397 0118 8093 0000 		sts usbMsgPtr,r24
 398 011c 84E1      		ldi r24,lo8(20)
 399 011e 00C0      		rjmp .L20
 400               	.L22:
 401               	.LBE61:
 341:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 402               		.stabn	68,0,341,.LM45-.LFBB2
 403               	.LM45:
 404 0120 8132      		cpi r24,lo8(33)
 405 0122 01F4      		brne .L25
 342:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
GAS LISTING /tmp/cccLNHGr.s 			page 19


 406               		.stabn	68,0,342,.LM46-.LFBB2
 407               	.LM46:
 408 0124 80E0      		ldi r24,lo8(usbDescriptorConfiguration+18)
 409 0126 90E0      		ldi r25,hi8(usbDescriptorConfiguration+18)
 410 0128 9093 0000 		sts usbMsgPtr+1,r25
 411 012c 8093 0000 		sts usbMsgPtr,r24
 412 0130 89E0      		ldi r24,lo8(9)
 413 0132 00C0      		rjmp .L20
 414               	.L25:
 343:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 415               		.stabn	68,0,343,.LM47-.LFBB2
 416               	.LM47:
 417 0134 8232      		cpi r24,lo8(34)
 418 0136 01F4      		brne .L49
 344:usbdrv/usbdrv.c **** #endif
 419               		.stabn	68,0,344,.LM48-.LFBB2
 420               	.LM48:
 421 0138 80E0      		ldi r24,lo8(usbDescriptorHidReport)
 422 013a 90E0      		ldi r25,hi8(usbDescriptorHidReport)
 423 013c 9093 0000 		sts usbMsgPtr+1,r25
 424 0140 8093 0000 		sts usbMsgPtr,r24
 425 0144 86E1      		ldi r24,lo8(22)
 426 0146 00C0      		rjmp .L20
 427               	.L49:
 428               	.LBE60:
 311:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 429               		.stabn	68,0,311,.LM49-.LFBB2
 430               	.LM49:
 431 0148 80E0      		ldi r24,0
 432               	.L20:
 351:usbdrv/usbdrv.c ****     return len;
 433               		.stabn	68,0,351,.LM50-.LFBB2
 434               	.LM50:
 435 014a 90E4      		ldi r25,lo8(64)
 436 014c 9093 0000 		sts usbMsgFlags,r25
 437 0150 00C0      		rjmp .L14
 438               	.L18:
 439               	.LBE59:
 440               	.LBE58:
 394:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 441               		.stabn	68,0,394,.LM51-.LFBB2
 442               	.LM51:
 443 0152 8830      		cpi r24,lo8(8)
 444 0154 01F0      		breq .L50
 397:usbdrv/usbdrv.c ****         usbConfiguration = value;
 445               		.stabn	68,0,397,.LM52-.LFBB2
 446               	.LM52:
 447 0156 8930      		cpi r24,lo8(9)
 448 0158 01F4      		brne .L27
 398:usbdrv/usbdrv.c ****         usbResetStall();
 449               		.stabn	68,0,398,.LM53-.LFBB2
 450               	.LM53:
 451 015a 9093 0000 		sts usbConfiguration,r25
 452 015e 00C0      		rjmp .L52
 453               	.L27:
 400:usbdrv/usbdrv.c ****         len = 1;
 454               		.stabn	68,0,400,.LM54-.LFBB2
GAS LISTING /tmp/cccLNHGr.s 			page 20


 455               	.LM54:
 456 0160 8A30      		cpi r24,lo8(10)
 457 0162 01F0      		breq .L51
 403:usbdrv/usbdrv.c ****         usbResetDataToggling();
 458               		.stabn	68,0,403,.LM55-.LFBB2
 459               	.LM55:
 460 0164 8B30      		cpi r24,lo8(11)
 461 0166 01F4      		brne .L52
 462               	.LBB62:
 463               	.LBB63:
 198:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 464               		.stabn	68,0,198,.LM56-.LFBB2
 465               	.LM56:
 466 0168 8BE4      		ldi r24,lo8(75)
 467 016a 8093 0000 		sts usbTxStatus1+1,r24
 468 016e 00C0      		rjmp .L52
 469               	.L50:
 470               	.LBE63:
 471               	.LBE62:
 395:usbdrv/usbdrv.c ****         len = 1;
 472               		.stabn	68,0,395,.LM57-.LFBB2
 473               	.LM57:
 474 0170 20E0      		ldi r18,lo8(usbConfiguration)
 475 0172 30E0      		ldi r19,hi8(usbConfiguration)
 476 0174 00C0      		rjmp .L70
 477               	.L51:
 478               	.LBE65:
 363:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 479               		.stabn	68,0,363,.LM58-.LFBB2
 480               	.LM58:
 481 0176 20E0      		ldi r18,lo8(usbTxBuf+9)
 482 0178 30E0      		ldi r19,hi8(usbTxBuf+9)
 483               	.L70:
 484               	.LBB66:
 401:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 485               		.stabn	68,0,401,.LM59-.LFBB2
 486               	.LM59:
 487 017a 81E0      		ldi r24,lo8(1)
 488 017c 00C0      		rjmp .L16
 489               	.L52:
 490               	.LBE66:
 363:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 491               		.stabn	68,0,363,.LM60-.LFBB2
 492               	.LM60:
 493 017e 20E0      		ldi r18,lo8(usbTxBuf+9)
 494 0180 30E0      		ldi r19,hi8(usbTxBuf+9)
 362:usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 495               		.stabn	68,0,362,.LM61-.LFBB2
 496               	.LM61:
 497 0182 80E0      		ldi r24,0
 498               	.L16:
 410:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 499               		.stabn	68,0,410,.LM62-.LFBB2
 500               	.LM62:
 501 0184 3093 0000 		sts usbMsgPtr+1,r19
 502 0188 2093 0000 		sts usbMsgPtr,r18
 503               	.L26:
GAS LISTING /tmp/cccLNHGr.s 			page 21


 504 018c 00C0      		rjmp .L14
 505               	.L13:
 506               	.LBE67:
 507               	.LBE68:
 454:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 508               		.stabn	68,0,454,.LM63-.LFBB2
 509               	.LM63:
 510 018e 9881      		ld r25,Y
 511 0190 97FD      		sbrc r25,7
 456:usbdrv/usbdrv.c ****                 }else{
 512               		.stabn	68,0,456,.LM64-.LFBB2
 513               	.LM64:
 514 0192 8E81      		ldd r24,Y+6
 515               	.L28:
 461:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 516               		.stabn	68,0,461,.LM65-.LFBB2
 517               	.LM65:
 518 0194 90E8      		ldi r25,lo8(-128)
 519 0196 9093 0000 		sts usbMsgFlags,r25
 520 019a 00C0      		rjmp .L29
 521               	.L14:
 465:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 522               		.stabn	68,0,465,.LM66-.LFBB2
 523               	.LM66:
 524 019c 9F81      		ldd r25,Y+7
 525 019e 9111      		cpse r25,__zero_reg__
 526 01a0 00C0      		rjmp .L29
 527 01a2 9E81      		ldd r25,Y+6
 528 01a4 9817      		cp r25,r24
 529 01a6 00F4      		brsh .L29
 530 01a8 892F      		mov r24,r25
 531               	.L29:
 471:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 532               		.stabn	68,0,471,.LM67-.LFBB2
 533               	.LM67:
 534 01aa 8093 0000 		sts usbMsgLen,r24
 535 01ae 00C0      		rjmp .L11
 536               	.L9:
 537               	.LBE69:
 474:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 538               		.stabn	68,0,474,.LM68-.LFBB2
 539               	.LM68:
 540 01b0 8091 0000 		lds r24,usbMsgFlags
 541 01b4 87FF      		sbrs r24,7
 542 01b6 00C0      		rjmp .L11
 543               	.LBB70:
 475:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 544               		.stabn	68,0,475,.LM69-.LFBB2
 545               	.LM69:
 546 01b8 CE01      		movw r24,r28
 547 01ba 0E94 0000 		call usbFunctionWrite
 476:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 548               		.stabn	68,0,476,.LM70-.LFBB2
 549               	.LM70:
 550 01be 8F3F      		cpi r24,lo8(-1)
 551 01c0 01F4      		brne .L32
 477:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
GAS LISTING /tmp/cccLNHGr.s 			page 22


 552               		.stabn	68,0,477,.LM71-.LFBB2
 553               	.LM71:
 554 01c2 8EE1      		ldi r24,lo8(30)
 555 01c4 8093 0000 		sts usbTxLen,r24
 556 01c8 00C0      		rjmp .L11
 557               	.L32:
 478:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 558               		.stabn	68,0,478,.LM72-.LFBB2
 559               	.LM72:
 560 01ca 8111      		cpse r24,__zero_reg__
 479:usbdrv/usbdrv.c ****             }
 561               		.stabn	68,0,479,.LM73-.LFBB2
 562               	.LM73:
 563 01cc 1092 0000 		sts usbMsgLen,__zero_reg__
 564               	.L11:
 565               	.LBE70:
 566               	.LBE71:
 567               	.LBE72:
 582:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 583:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 584:usbdrv/usbdrv.c ****             usbRxLen = 0;
 585:usbdrv/usbdrv.c **** #else
 586:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 568               		.stabn	68,0,586,.LM74-.LFBB2
 569               	.LM74:
 570 01d0 1092 0000 		sts usbRxLen,__zero_reg__
 571               	.L8:
 587:usbdrv/usbdrv.c **** #endif
 588:usbdrv/usbdrv.c ****     }
 589:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 572               		.stabn	68,0,589,.LM75-.LFBB2
 573               	.LM75:
 574 01d4 8091 0000 		lds r24,usbTxLen
 575 01d8 84FF      		sbrs r24,4
 576 01da 00C0      		rjmp .L33
 590:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 577               		.stabn	68,0,590,.LM76-.LFBB2
 578               	.LM76:
 579 01dc 8091 0000 		lds r24,usbMsgLen
 580 01e0 8F3F      		cpi r24,lo8(-1)
 581 01e2 01F4      		brne .+2
 582 01e4 00C0      		rjmp .L33
 583 01e6 C82F      		mov r28,r24
 584 01e8 8930      		cpi r24,lo8(9)
 585 01ea 00F0      		brlo .L34
 586 01ec C8E0      		ldi r28,lo8(8)
 587               	.L34:
 588               	.LBB73:
 589               	.LBB74:
 533:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 590               		.stabn	68,0,533,.LM77-.LFBB2
 591               	.LM77:
 592 01ee 8C1B      		sub r24,r28
 593 01f0 8093 0000 		sts usbMsgLen,r24
 534:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 594               		.stabn	68,0,534,.LM78-.LFBB2
 595               	.LM78:
GAS LISTING /tmp/cccLNHGr.s 			page 23


 596 01f4 8091 0000 		lds r24,usbTxBuf
 597 01f8 98E8      		ldi r25,lo8(-120)
 598 01fa 8927      		eor r24,r25
 599 01fc 8093 0000 		sts usbTxBuf,r24
 600               	.LBB75:
 601               	.LBB76:
 493:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 602               		.stabn	68,0,493,.LM79-.LFBB2
 603               	.LM79:
 604 0200 CC23      		tst r28
 605 0202 01F0      		breq .L35
 495:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 606               		.stabn	68,0,495,.LM80-.LFBB2
 607               	.LM80:
 608 0204 8091 0000 		lds r24,usbMsgFlags
 609 0208 87FF      		sbrs r24,7
 610 020a 00C0      		rjmp .L36
 496:usbdrv/usbdrv.c ****         }else
 611               		.stabn	68,0,496,.LM81-.LFBB2
 612               	.LM81:
 613 020c 6C2F      		mov r22,r28
 614 020e 80E0      		ldi r24,lo8(usbTxBuf+1)
 615 0210 90E0      		ldi r25,hi8(usbTxBuf+1)
 616 0212 0E94 0000 		call usbFunctionRead
 617 0216 C82F      		mov r28,r24
 618               	.LBE76:
 619               	.LBE75:
 536:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 620               		.stabn	68,0,536,.LM82-.LFBB2
 621               	.LM82:
 622 0218 8930      		cpi r24,lo8(9)
 623 021a 00F4      		brsh .L68
 624 021c 00C0      		rjmp .L35
 625               	.L36:
 626               	.LBB81:
 627               	.LBB80:
 628               	.LBB77:
 501:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 629               		.stabn	68,0,501,.LM83-.LFBB2
 630               	.LM83:
 631 021e 4091 0000 		lds r20,usbMsgPtr
 632 0222 5091 0000 		lds r21,usbMsgPtr+1
 502:usbdrv/usbdrv.c ****                 do{
 633               		.stabn	68,0,502,.LM84-.LFBB2
 634               	.LM84:
 635 0226 86FF      		sbrs r24,6
 636 0228 00C0      		rjmp .L38
 637 022a A0E0      		ldi r26,lo8(usbTxBuf+1)
 638 022c B0E0      		ldi r27,hi8(usbTxBuf+1)
 639 022e FA01      		movw r30,r20
 640 0230 8C2F      		mov r24,r28
 641 0232 8A0F      		add r24,r26
 642               	.L41:
 643               	.LBB78:
 644               	.LBB79:
 504:usbdrv/usbdrv.c ****                     *data++ = c;
 645               		.stabn	68,0,504,.LM85-.LFBB2
GAS LISTING /tmp/cccLNHGr.s 			page 24


 646               	.LM85:
 647               	/* #APP */
 648               	 ;  504 "usbdrv/usbdrv.c" 1
 649 0234 9491      		lpm r25, Z
 650               		
 651               	 ;  0 "" 2
 652               	/* #NOAPP */
 653               	.LBE79:
 505:usbdrv/usbdrv.c ****                     r++;
 654               		.stabn	68,0,505,.LM86-.LFBB2
 655               	.LM86:
 656 0236 9D93      		st X+,r25
 506:usbdrv/usbdrv.c ****                 }while(--i);
 657               		.stabn	68,0,506,.LM87-.LFBB2
 658               	.LM87:
 659 0238 3196      		adiw r30,1
 660               	.LBE78:
 507:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 661               		.stabn	68,0,507,.LM88-.LFBB2
 662               	.LM88:
 663 023a 8A13      		cpse r24,r26
 664 023c 00C0      		rjmp .L41
 665 023e 00C0      		rjmp .L71
 666               	.L38:
 667 0240 DA01      		movw r26,r20
 502:usbdrv/usbdrv.c ****                 do{
 668               		.stabn	68,0,502,.LM89-.LFBB2
 669               	.LM89:
 670 0242 E0E0      		ldi r30,lo8(usbTxBuf+1)
 671 0244 F0E0      		ldi r31,hi8(usbTxBuf+1)
 672 0246 8C2F      		mov r24,r28
 673 0248 8E0F      		add r24,r30
 674               	.L43:
 510:usbdrv/usbdrv.c ****                     r++;
 675               		.stabn	68,0,510,.LM90-.LFBB2
 676               	.LM90:
 677 024a 9D91      		ld r25,X+
 678 024c 9193      		st Z+,r25
 512:usbdrv/usbdrv.c ****             }
 679               		.stabn	68,0,512,.LM91-.LFBB2
 680               	.LM91:
 681 024e 8E13      		cpse r24,r30
 682 0250 00C0      		rjmp .L43
 683               	.L71:
 684 0252 2FEF      		ldi r18,lo8(-1)
 685 0254 2C0F      		add r18,r28
 686 0256 30E0      		ldi r19,0
 687 0258 2F5F      		subi r18,-1
 688 025a 3F4F      		sbci r19,-1
 689 025c 240F      		add r18,r20
 690 025e 351F      		adc r19,r21
 514:usbdrv/usbdrv.c ****         }
 691               		.stabn	68,0,514,.LM92-.LFBB2
 692               	.LM92:
 693 0260 3093 0000 		sts usbMsgPtr+1,r19
 694 0264 2093 0000 		sts usbMsgPtr,r18
 695               	.L35:
GAS LISTING /tmp/cccLNHGr.s 			page 25


 696               	.LBE77:
 697               	.LBE80:
 698               	.LBE81:
 537:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 699               		.stabn	68,0,537,.LM93-.LFBB2
 700               	.LM93:
 701 0268 6C2F      		mov r22,r28
 702 026a 80E0      		ldi r24,lo8(usbTxBuf+1)
 703 026c 90E0      		ldi r25,hi8(usbTxBuf+1)
 704 026e 0E94 0000 		call usbCrc16Append
 538:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 705               		.stabn	68,0,538,.LM94-.LFBB2
 706               	.LM94:
 707 0272 CC5F      		subi r28,lo8(-(4))
 539:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 708               		.stabn	68,0,539,.LM95-.LFBB2
 709               	.LM95:
 710 0274 CC30      		cpi r28,lo8(12)
 711 0276 01F0      		breq .L44
 540:usbdrv/usbdrv.c ****     }else{
 712               		.stabn	68,0,540,.LM96-.LFBB2
 713               	.LM96:
 714 0278 8FEF      		ldi r24,lo8(-1)
 715 027a 8093 0000 		sts usbMsgLen,r24
 716 027e 00C0      		rjmp .L44
 717               	.L68:
 543:usbdrv/usbdrv.c ****     }
 718               		.stabn	68,0,543,.LM97-.LFBB2
 719               	.LM97:
 720 0280 8FEF      		ldi r24,lo8(-1)
 721 0282 8093 0000 		sts usbMsgLen,r24
 542:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 722               		.stabn	68,0,542,.LM98-.LFBB2
 723               	.LM98:
 724 0286 CEE1      		ldi r28,lo8(30)
 725               	.L44:
 545:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 726               		.stabn	68,0,545,.LM99-.LFBB2
 727               	.LM99:
 728 0288 C093 0000 		sts usbTxLen,r28
 729               	.L33:
 542:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 730               		.stabn	68,0,542,.LM100-.LFBB2
 731               	.LM100:
 732 028c 84E1      		ldi r24,lo8(20)
 733               	.L47:
 734               	.LBE74:
 735               	.LBE73:
 736               	.LBB82:
 591:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 592:usbdrv/usbdrv.c ****         }
 593:usbdrv/usbdrv.c ****     }
 594:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 595:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 737               		.stabn	68,0,595,.LM101-.LFBB2
 738               	.LM101:
 739 028e 99B1      		in r25,0x9
GAS LISTING /tmp/cccLNHGr.s 			page 26


 740 0290 9670      		andi r25,lo8(6)
 596:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 741               		.stabn	68,0,596,.LM102-.LFBB2
 742               	.LM102:
 743 0292 01F4      		brne .L7
 744 0294 8150      		subi r24,lo8(-(-1))
 745               	.LBE82:
 594:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 746               		.stabn	68,0,594,.LM103-.LFBB2
 747               	.LM103:
 748 0296 01F4      		brne .L47
 597:usbdrv/usbdrv.c ****             goto isNotReset;
 598:usbdrv/usbdrv.c ****     }
 599:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 600:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 749               		.stabn	68,0,600,.LM104-.LFBB2
 750               	.LM104:
 751 0298 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 601:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 752               		.stabn	68,0,601,.LM105-.LFBB2
 753               	.LM105:
 754 029c 1092 0000 		sts usbDeviceAddr,__zero_reg__
 755               	.L45:
 756               	.L7:
 757               	/* epilogue start */
 602:usbdrv/usbdrv.c ****     usbResetStall();
 603:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 604:usbdrv/usbdrv.c **** isNotReset:
 605:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 606:usbdrv/usbdrv.c **** }
 758               		.stabn	68,0,606,.LM106-.LFBB2
 759               	.LM106:
 760 02a0 DF91      		pop r29
 761 02a2 CF91      		pop r28
 762 02a4 0895      		ret
 763               		.size	usbPoll, .-usbPoll
 764               		.stabs	"dataPtr:r(0,48)=*(0,11)",64,0,363,18
 765               		.stabs	"value:r(0,11)",64,0,364,25
 766               		.stabn	192,0,0,.LBB54-.LFBB2
 767               		.stabs	"_cmd:r(0,11)",64,0,370,24
 768               		.stabn	192,0,0,.LBB55-.LFBB2
 769               		.stabs	"_cmd:r(0,11)",64,0,314,24
 770               		.stabn	192,0,0,.LBB60-.LFBB2
 771               		.stabn	224,0,0,.LBE60-.LFBB2
 772               		.stabn	224,0,0,.LBE55-.LFBB2
 773               		.stabs	"_cmd:r(0,11)",64,0,370,24
 774               		.stabn	192,0,0,.LBB64-.LFBB2
 775               		.stabn	224,0,0,.LBE64-.LFBB2
 776               		.stabs	"_cmd:r(0,11)",64,0,370,24
 777               		.stabn	192,0,0,.LBB65-.LFBB2
 778               		.stabn	224,0,0,.LBE65-.LFBB2
 779               		.stabs	"_cmd:r(0,11)",64,0,370,24
 780               		.stabn	192,0,0,.LBB66-.LFBB2
 781               		.stabn	224,0,0,.LBE66-.LFBB2
 782               		.stabn	224,0,0,.LBE54-.LFBB2
 783               		.stabs	"dataPtr:r(0,48)",64,0,363,18
 784               		.stabs	"value:r(0,11)",64,0,364,25
GAS LISTING /tmp/cccLNHGr.s 			page 27


 785               		.stabn	192,0,0,.LBB67-.LFBB2
 786               		.stabn	224,0,0,.LBE67-.LFBB2
 787               		.stabs	"rval:r(0,11)",64,0,475,24
 788               		.stabn	192,0,0,.LBB70-.LFBB2
 789               		.stabn	224,0,0,.LBE70-.LFBB2
 790               	.Lscope2:
 791               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 792               		.stabd	78,0,0
 793               		.stabs	"usbInit:F(0,47)",36,0,610,usbInit
 794               	.global	usbInit
 795               		.type	usbInit, @function
 796               	usbInit:
 797               		.stabd	46,0,0
 607:usbdrv/usbdrv.c **** 
 608:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 609:usbdrv/usbdrv.c **** 
 610:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 611:usbdrv/usbdrv.c **** {
 798               		.stabn	68,0,611,.LM107-.LFBB3
 799               	.LM107:
 800               	.LFBB3:
 801               	/* prologue: function */
 802               	/* frame size = 0 */
 803               	/* stack size = 0 */
 804               	.L__stack_usage = 0
 612:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 613:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 805               		.stabn	68,0,613,.LM108-.LFBB3
 806               	.LM108:
 807 02a6 E9E6      		ldi r30,lo8(105)
 808 02a8 F0E0      		ldi r31,0
 809 02aa 8081      		ld r24,Z
 810 02ac 8260      		ori r24,lo8(2)
 811 02ae 8083      		st Z,r24
 614:usbdrv/usbdrv.c **** #endif
 615:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 616:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 617:usbdrv/usbdrv.c **** #endif
 618:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 812               		.stabn	68,0,618,.LM109-.LFBB3
 813               	.LM109:
 814 02b0 E89A      		sbi 0x1d,0
 815               	.LBB83:
 816               	.LBB84:
 198:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 817               		.stabn	68,0,198,.LM110-.LFBB3
 818               	.LM110:
 819 02b2 8BE4      		ldi r24,lo8(75)
 820 02b4 8093 0000 		sts usbTxStatus1+1,r24
 821               	.LBE84:
 822               	.LBE83:
 619:usbdrv/usbdrv.c ****     usbResetDataToggling();
 620:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 621:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 823               		.stabn	68,0,621,.LM111-.LFBB3
 824               	.LM111:
 825 02b8 8AE5      		ldi r24,lo8(90)
GAS LISTING /tmp/cccLNHGr.s 			page 28


 826 02ba 8093 0000 		sts usbTxStatus1,r24
 827 02be 0895      		ret
 828               		.size	usbInit, .-usbInit
 829               	.Lscope3:
 830               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 831               		.stabd	78,0,0
 832               	.global	usbDescriptorConfiguration
 833               		.section	.progmem.data,"a",@progbits
 834               		.type	usbDescriptorConfiguration, @object
 835               		.size	usbDescriptorConfiguration, 34
 836               	usbDescriptorConfiguration:
 837 0000 09        		.byte	9
 838 0001 02        		.byte	2
 839 0002 22        		.byte	34
 840 0003 00        		.byte	0
 841 0004 01        		.byte	1
 842 0005 01        		.byte	1
 843 0006 00        		.byte	0
 844 0007 80        		.byte	-128
 845 0008 0A        		.byte	10
 846 0009 09        		.byte	9
 847 000a 04        		.byte	4
 848 000b 00        		.byte	0
 849 000c 00        		.byte	0
 850 000d 01        		.byte	1
 851 000e 03        		.byte	3
 852 000f 00        		.byte	0
 853 0010 00        		.byte	0
 854 0011 00        		.byte	0
 855 0012 09        		.byte	9
 856 0013 21        		.byte	33
 857 0014 01        		.byte	1
 858 0015 01        		.byte	1
 859 0016 00        		.byte	0
 860 0017 01        		.byte	1
 861 0018 22        		.byte	34
 862 0019 16        		.byte	22
 863 001a 00        		.byte	0
 864 001b 07        		.byte	7
 865 001c 05        		.byte	5
 866 001d 81        		.byte	-127
 867 001e 03        		.byte	3
 868 001f 08        		.byte	8
 869 0020 00        		.byte	0
 870 0021 64        		.byte	100
 871               	.global	usbDescriptorDevice
 872               		.type	usbDescriptorDevice, @object
 873               		.size	usbDescriptorDevice, 18
 874               	usbDescriptorDevice:
 875 0022 12        		.byte	18
 876 0023 01        		.byte	1
 877 0024 10        		.byte	16
 878 0025 01        		.byte	1
 879 0026 00        		.byte	0
 880 0027 00        		.byte	0
 881 0028 00        		.byte	0
 882 0029 08        		.byte	8
GAS LISTING /tmp/cccLNHGr.s 			page 29


 883 002a C0        		.byte	-64
 884 002b 16        		.byte	22
 885 002c DF        		.byte	-33
 886 002d 05        		.byte	5
 887 002e 00        		.byte	0
 888 002f 01        		.byte	1
 889 0030 01        		.byte	1
 890 0031 02        		.byte	2
 891 0032 00        		.byte	0
 892 0033 01        		.byte	1
 893               	.global	usbDescriptorStringDevice
 894               		.type	usbDescriptorStringDevice, @object
 895               		.size	usbDescriptorStringDevice, 20
 896               	usbDescriptorStringDevice:
 897 0034 1403      		.word	788
 898 0036 4400      		.word	68
 899 0038 6100      		.word	97
 900 003a 7400      		.word	116
 901 003c 6100      		.word	97
 902 003e 5300      		.word	83
 903 0040 7400      		.word	116
 904 0042 6F00      		.word	111
 905 0044 7200      		.word	114
 906 0046 6500      		.word	101
 907               	.global	usbDescriptorStringVendor
 908               		.type	usbDescriptorStringVendor, @object
 909               		.size	usbDescriptorStringVendor, 18
 910               	usbDescriptorStringVendor:
 911 0048 1203      		.word	786
 912 004a 6F00      		.word	111
 913 004c 6200      		.word	98
 914 004e 6400      		.word	100
 915 0050 6500      		.word	101
 916 0052 7600      		.word	118
 917 0054 2E00      		.word	46
 918 0056 6100      		.word	97
 919 0058 7400      		.word	116
 920               	.global	usbDescriptorString0
 921               		.type	usbDescriptorString0, @object
 922               		.size	usbDescriptorString0, 4
 923               	usbDescriptorString0:
 924 005a 04        		.byte	4
 925 005b 03        		.byte	3
 926 005c 09        		.byte	9
 927 005d 04        		.byte	4
 928               		.local	usbMsgFlags
 929               		.comm	usbMsgFlags,1,1
 930               		.data
 931               		.type	usbMsgLen, @object
 932               		.size	usbMsgLen, 1
 933               	usbMsgLen:
 934 0000 FF        		.byte	-1
 935               		.comm	usbMsgPtr,2,1
 936               		.comm	usbTxStatus1,12,1
 937               		.comm	usbTxBuf,11,1
 938               	.global	usbTxLen
 939               		.type	usbTxLen, @object
GAS LISTING /tmp/cccLNHGr.s 			page 30


 940               		.size	usbTxLen, 1
 941               	usbTxLen:
 942 0001 5A        		.byte	90
 943               		.comm	usbRxToken,1,1
 944               		.comm	usbCurrentTok,1,1
 945               		.comm	usbRxLen,1,1
 946               		.comm	usbConfiguration,1,1
 947               		.comm	usbNewDeviceAddr,1,1
 948               		.comm	usbDeviceAddr,1,1
 949               		.comm	usbInputBufOffset,1,1
 950               		.comm	usbRxBuf,22,1
 951               		.stabs	"usbMsgLen:S(0,11)",38,0,47,usbMsgLen
 952               		.stabs	"usbMsgFlags:S(0,11)",40,0,48,usbMsgFlags
 953               		.stabs	"usbMsgPtr:G(0,48)",32,0,46,0
 954               		.stabs	"usbRxToken:G(0,11)",32,0,29,0
 955               		.stabs	"usbConfiguration:G(0,11)",32,0,26,0
 956               		.stabs	"usbDescriptorDevice:G(0,49)=ar(1,4);0;17;(0,50)=k(0,2)",32,0,109,0
 957               		.stabs	"usbDescriptorConfiguration:G(0,51)=ar(1,4);0;33;(0,50)",32,0,140,0
 958               		.stabs	"usbDescriptorString0:G(0,52)=ar(1,4);0;3;(0,50)",32,0,68,0
 959               		.stabs	"usbDescriptorStringVendor:G(0,53)=ar(1,4);0;8;(0,54)=k(0,1)",32,0,78,0
 960               		.stabs	"usbDescriptorStringDevice:G(0,55)=ar(1,4);0;9;(0,54)",32,0,87,0
 961               		.stabs	"usbTxStatus1:G(1,5)",32,0,36,0
 962               		.stabs	"usbRxBuf:G(0,56)=ar(1,4);0;21;(0,11)",32,0,22,0
 963               		.stabs	"usbInputBufOffset:G(0,11)",32,0,23,0
 964               		.stabs	"usbDeviceAddr:G(0,11)",32,0,24,0
 965               		.stabs	"usbNewDeviceAddr:G(0,11)",32,0,25,0
 966               		.stabs	"usbRxLen:G(0,57)=B(0,10)",32,0,27,0
 967               		.stabs	"usbCurrentTok:G(0,11)",32,0,28,0
 968               		.stabs	"usbTxLen:G(1,2)",32,0,30,0
 969               		.stabs	"usbTxBuf:G(1,3)",32,0,31,0
 970               		.text
 971               		.stabs	"",100,0,0,.Letext0
 972               	.Letext0:
 973               		.ident	"GCC: (GNU) 4.8.1"
 974               	.global __do_copy_data
 975               	.global __do_clear_bss
GAS LISTING /tmp/cccLNHGr.s 			page 31


DEFINED SYMBOLS
                            *ABS*:0000000000000000 usbdrv.c
     /tmp/cccLNHGr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cccLNHGr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cccLNHGr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cccLNHGr.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cccLNHGr.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cccLNHGr.s:121    .text:0000000000000000 usbSetInterrupt
                            *COM*:000000000000000c usbTxStatus1
     /tmp/cccLNHGr.s:196    .text:0000000000000046 usbPoll
                            *COM*:0000000000000001 usbRxLen
                            *COM*:0000000000000001 usbInputBufOffset
                            *COM*:0000000000000016 usbRxBuf
                            *COM*:0000000000000001 usbRxToken
                            *COM*:000000000000000b usbTxBuf
     /tmp/cccLNHGr.s:941    .data:0000000000000001 usbTxLen
                             .bss:0000000000000000 usbMsgFlags
                            *COM*:0000000000000001 usbNewDeviceAddr
     /tmp/cccLNHGr.s:874    .progmem.data:0000000000000022 usbDescriptorDevice
     /tmp/cccLNHGr.s:836    .progmem.data:0000000000000000 usbDescriptorConfiguration
                            *COM*:0000000000000002 usbMsgPtr
     /tmp/cccLNHGr.s:923    .progmem.data:000000000000005a usbDescriptorString0
     /tmp/cccLNHGr.s:910    .progmem.data:0000000000000048 usbDescriptorStringVendor
     /tmp/cccLNHGr.s:896    .progmem.data:0000000000000034 usbDescriptorStringDevice
                            *COM*:0000000000000001 usbConfiguration
     /tmp/cccLNHGr.s:933    .data:0000000000000000 usbMsgLen
                            *COM*:0000000000000001 usbDeviceAddr
     /tmp/cccLNHGr.s:796    .text:00000000000002a6 usbInit
                            *COM*:0000000000000001 usbCurrentTok

UNDEFINED SYMBOLS
usbCrc16Append
usbFunctionSetup
usbDescriptorHidReport
usbFunctionWrite
usbFunctionRead
__do_copy_data
__do_clear_bss
